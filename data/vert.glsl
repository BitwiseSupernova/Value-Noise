#ifdef GL_ESprecision highp float;#endif// Inputs copied from other shaders...uniform mat4 projection;attribute vec4 color;uniform mat4 transformMatrix;uniform mat4 modelview;uniform mat3 normalMatrix;attribute vec4 vertex;attribute vec4 position;attribute vec3 normal;// Used to generate scenevarying vec4 vertexColor;uniform vec3 lamp;uniform vec2 offset;uniform vec3 primes;uniform float viewscale;uniform float landHeight;float rnd(vec2 p){  float v = dot(p, primes.xy);  return fract( sin( v ) * primes.z);}float interpolate(vec2 p){  vec2 iv = floor(p);  vec2 fv = fract(p);  // add smoothing function here  // 'zero' vector is just for aligning text  float x1 = mix(rnd(vec2(0.,0.)+iv), rnd(vec2(1.,0.)+iv), fv.x);  float x2 = mix(rnd(vec2(0.,1.)+iv), rnd(vec2(1.,1.)+iv), fv.x);  return mix(x1, x2, fv.y);}float valueNoise(vec2 p){  float sum = 0.0;  float freq = 4.0;  float mult = 0.5;  for (int i=0; i<4; i++)  {    sum += mult * interpolate( freq*(p + offset) );    freq *= 2.0;    mult *= 0.5;  }  return sum * 0.7;}void main(){  vec4 loc = position;  loc.y = valueNoise(viewscale*loc.xz);  float dx = valueNoise(viewscale*(loc.xz + vec2(1.0,0.0)));  float dz = valueNoise(viewscale*(loc.xz + vec2(0.0,1.0)));    vec3 n = vec3(dx, loc.y, dz);  vec3 lampdir = normalize(lamp);  float mag = dot(n, lampdir);    loc.y *= landHeight;  //gl_Position = transformMatrix * loc;  vec4 pos = modelview * loc;  vec4 clip = projection * pos;  gl_Position = clip + projection * vec4(offset, 0, 0);    vec3 col = vec3(0.0, 1.0, 0.0);  vertexColor = vec4(col*mag, 1.);}